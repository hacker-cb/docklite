---
globs: backend/app/api/*.py
description: Backend API endpoint patterns and conventions
---

# Backend API Conventions

## Authentication

All endpoints EXCEPT `/api/auth/*` and `/api/presets/*` require JWT authentication:

```python
from app.core.security import get_current_active_user
from app.models.user import User

@router.get("/protected")
async def protected_endpoint(
    current_user: User = Depends(get_current_active_user)
):
    # current_user is authenticated User object
    pass
```

## Admin-Only Endpoints

User management endpoints require admin check:

```python
def check_is_admin(current_user: User):
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="Admin access required")

@router.get("/admin-only")
async def admin_endpoint(
    current_user: User = Depends(get_current_active_user)
):
    check_is_admin(current_user)
    # ... admin logic
```

## Response Serialization

For Project model, use helper function to convert SQLAlchemy to dict:

```python
def project_to_response(project: Project) -> dict:
    return {
        "id": project.id,
        "name": project.name,
        "domain": project.domain,
        "compose_content": project.compose_content,
        "env_vars": json.loads(project.env_vars or "{}"),
        "status": project.status,
        "created_at": project.created_at,
        "updated_at": project.updated_at
    }
```

DO NOT modify SQLAlchemy objects directly - causes autoflush issues.

## Error Handling

Standard patterns:
- 400 BAD_REQUEST - validation errors, business logic errors
- 401 UNAUTHORIZED - missing/invalid token
- 403 FORBIDDEN - not enough permissions
- 404 NOT_FOUND - resource not found
- 422 UNPROCESSABLE_ENTITY - Pydantic validation errors (automatic)

## API Router Pattern

All routers follow this pattern:
- Import from `app.api` in [backend/app/main.py](mdc:backend/app/main.py)
- Use prefix: `/api`
- Tag for OpenAPI docs
- Async functions
- Type hints with Pydantic schemas
