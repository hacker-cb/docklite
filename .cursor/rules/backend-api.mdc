---
description: Backend API endpoint patterns and conventions
globs: ["backend/app/api/**/*.py", "backend/app/constants/*.py", "backend/app/utils/*.py", "backend/app/validators/*.py"]
tags: ["python", "fastapi", "backend"]
---

# Backend API Conventions

## Architecture

**Layered structure:**
```
API → Services → Models
 ↓       ↓
Utils  Constants
 ↓       ↓
Validators, Exceptions
```

## Constants (ALWAYS use!)

```python
from app.constants.project_constants import ProjectStatus
from app.constants.messages import ErrorMessages, SuccessMessages

project.status = ProjectStatus.CREATED  # NOT "created"
raise HTTPException(detail=ErrorMessages.PROJECT_NOT_FOUND)
```

## Utils & Formatters

```python
from app.utils.formatters import format_project_response
return format_project_response(project)  # NOT manual dict
```

## Validators

```python
from app.validators import validate_docker_compose
is_valid, error = validate_docker_compose(content)
```

## Authentication

All endpoints EXCEPT `/api/auth/*` and `/api/presets/*` require JWT authentication:

```python
from app.core.security import get_current_active_user
from app.models.user import User

@router.get("/protected")
async def protected_endpoint(
    current_user: User = Depends(get_current_active_user)
):
    # current_user is authenticated User object
    pass
```

## Admin-Only Endpoints

User management endpoints require admin check:

```python
def check_is_admin(current_user: User):
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="Admin access required")

@router.get("/admin-only")
async def admin_endpoint(
    current_user: User = Depends(get_current_active_user)
):
    check_is_admin(current_user)
    # ... admin logic
```

## Response Serialization

For Project model, use helper function to convert SQLAlchemy to dict:

```python
def project_to_response(project: Project) -> dict:
    return {
        "id": project.id,
        "name": project.name,
        "domain": project.domain,
        "compose_content": project.compose_content,
        "env_vars": json.loads(project.env_vars or "{}"),
        "status": project.status,
        "created_at": project.created_at,
        "updated_at": project.updated_at
    }
```

DO NOT modify SQLAlchemy objects directly - causes autoflush issues.

## Error Handling

Standard patterns:
- 400 BAD_REQUEST - validation errors, business logic errors
- 401 UNAUTHORIZED - missing/invalid token
- 403 FORBIDDEN - not enough permissions
- 404 NOT_FOUND - resource not found
- 422 UNPROCESSABLE_ENTITY - Pydantic validation errors (automatic)

## API Router Pattern

All routers follow this pattern:
- Import from `app.api` in [backend/app/main.py](mdc:backend/app/main.py)
- Use prefix: `/api`
- Tag for OpenAPI docs
- Async functions
- Type hints with Pydantic schemas
