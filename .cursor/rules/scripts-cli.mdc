---
description: DockLite CLI scripts patterns and conventions
---

# DockLite Scripts & CLI

## ⚠️ MIGRATION NOTICE

**Old:** Bash scripts (deprecated, will be removed)  
**New:** Python CLI with Typer + Rich ✅ **USE THIS!**

See [python-cli.mdc](mdc:.cursor/rules/python-cli.mdc) for Python CLI documentation.

## Main CLI (Python)

DockLite now uses modern Python CLI: `./docklite <command>`

**Entry Point:** [scripts/docklite](mdc:scripts/docklite) (Python executable)  
**Main App:** [scripts/cli/main.py](mdc:scripts/cli/main.py)

### Commands (17 total)

**Development:**
- `start [--build] [--follow]`, `stop [--volumes]`, `restart [--build]`, `rebuild [--no-cache]`
- `logs [service]`, `test`, `test-backend`, `test-frontend`

**Deployment:**
- `setup-user [--user] [--dir]`, `setup-ssh [--user]`, `init-db [--reset]`

**Maintenance:**
- `backup [--output]`, `restore <file>`, `clean [--all]`, `status [--verbose]`
- `list-users [--verbose]`, `reset-password <username> [--password]`

**Completion:**
- Built-in via Typer: `./docklite --install-completion bash`

## Structure (Python CLI)

```
scripts/
├── docklite                    # Python CLI entry point ✅
├── cli/
│   ├── main.py                # Typer app
│   ├── config.py              # Hostname functions, paths
│   ├── utils/                 # Console, docker, system, validation
│   └── commands/              # development, deployment, maintenance
├── tests/                      # 60 pytest tests ✅
└── requirements.txt

backend/app/cli_helpers/        # Database operations
├── list_users.py
└── reset_password.py

# Legacy (will be removed):
├── docklite.sh              # Old bash wrapper
├── lib/common.sh            # Old bash functions
├── development/             # Old bash scripts
├── deployment/
├── maintenance/
└── completion/
```

## Python CLI Utilities

**Location:** [scripts/cli/utils/console.py](mdc:scripts/cli/utils/console.py)

### Functions Available

**Logging (Rich):**
```python
from cli.utils.console import log_info, log_success, log_warning, log_error, log_step

log_info("message")      # ℹ Info with blue
log_success("message")   # ✅ Success with green
log_warning("message")   # ⚠️ Warning with yellow
log_error("message")     # ❌ Error with red
log_step("message")      # ▶ Step with cyan
print_banner("Title")    # Rich Panel
```

**Validation:**
```python
from cli.utils.validation import check_docker, check_docker_compose
from cli.utils.system import check_root, check_not_root

check_docker()           # Check Docker installed and running
check_docker_compose()   # Check docker-compose available  
check_root()             # Ensure running as root (raises PermissionError)
check_not_root()         # Ensure NOT root
```

**Docker:**
```python
from cli.utils.docker import docker_compose_cmd, is_container_running
from cli.config import PROJECT_ROOT

docker_compose_cmd("up", "-d", cwd=PROJECT_ROOT)
is_container_running("docklite-backend")  # Returns bool
```

**System:**
```python
from cli.utils.system import (
    get_actual_user,
    get_actual_home,
    user_exists,
    backup_file
)

user = get_actual_user()         # Get real user (even with sudo)
home = get_actual_home()         # Path object
exists = user_exists("docklite") # bool
backup = backup_file(Path("file.txt"))  # Creates timestamped backup
```

**Config:**
```python
from cli.config import (
    VERSION,              # "1.0.0"
    PROJECT_ROOT,         # Path("/home/pavel/docklite")
    get_hostname,         # Priority: .env > system > localhost
    get_access_url        # Build URLs
)

url = get_access_url("/api")  # ALWAYS use this!
```

## Command Template (Python/Typer)

When creating new commands:

```python
# scripts/cli/commands/my_category.py
import typer
from ..config import PROJECT_ROOT, get_access_url
from ..utils.console import log_info, log_success, log_step, print_banner
from ..utils.docker import docker_compose_cmd
from ..utils.validation import check_docker

app = typer.Typer(help="Category description")


@app.command()
def my_command(
    option: bool = typer.Option(False, "--option", "-o", help="Option description"),
    arg: str = typer.Argument(None, help="Argument description")
):
    """Command description for help."""
    print_banner("Command Title")
    
    log_step("Doing something...")
    # Your logic here
    log_success("Done!")


# Register in scripts/cli/main.py:
# from .commands import my_category
# app.add_typer(my_category.app, name="category")
# app.command(name="my-command")(my_category.my_command)
```

## Rules (Python CLI)

### ✅ ALWAYS

- **Use Typer decorators** (`@app.command()`)
- **Use Rich for output** (console, tables, panels)
- **Import from utils** (console, docker, system, validation)
- **Use get_access_url()** for all URLs (NEVER hardcode!)
- **Use docker_compose_cmd()** for docker operations
- **Type hints** on all parameters
- **Handle errors** with try/except and log_error
- **Write tests** for new commands
- **Check prerequisites** (check_docker, check_root)
- **Use backend helpers** for database operations

### ❌ NEVER

- **Hardcode URLs** (localhost:8000) - use `get_access_url()`
- **Hardcode paths** - use `PROJECT_ROOT`, `BACKUPS_DIR`
- **Pass long Python scripts** to docker exec - use backend helpers
- **Import single model** - always `from app.models import user, project`
- **Forget SQL logging** - disable in helpers
- **Use print()** - use Rich console functions
- **Call commands directly** - use explicit logic or pass params correctly
- **Skip type hints**  

## Adding New Commands (Python)

1. **Create command** in appropriate file:
   ```python
   # scripts/cli/commands/maintenance.py (or other)
   
   @app.command(name="my-command")
   def my_command(
       option: str = typer.Option("default", "--option", "-o", help="Description")
   ):
       """Command description."""
       print_banner("My Command")
       log_step("Doing something...")
       # Your logic
       log_success("Done!")
   ```

2. **Register in main.py:**
   ```python
   # scripts/cli/main.py
   from .commands import maintenance
   
   # Add at root level
   app.command(name="my-command")(maintenance.my_command)
   ```

3. **Write tests:**
   ```python
   # scripts/tests/test_commands_maintenance.py
   
   def test_my_command():
       """Test my command."""
       result = runner.invoke(app, ["my-command", "--option", "value"])
       assert result.exit_code == 0
   ```

4. **Completion is automatic** via Typer!

5. **Update docs:**
   - Add to [scripts/README.md](mdc:scripts/README.md)
   - Typer auto-generates help

## Auto-Completion (Typer)

**Built-in via Typer** - supports bash, zsh, fish, powershell

**Install:**
```bash
./docklite --install-completion bash  # Auto-detects shell
./docklite --show-completion bash     # Show completion script
source ~/.bashrc                       # Reload
```

Provides smart auto-completion for:
- ✅ All commands
- ✅ All options (--flags)
- ✅ Arguments with type hints
- ✅ Automatic updates when adding commands

## Testing (Python CLI)

**Run tests:**
```bash
cd scripts
python3 -m pytest tests/ -v          # All 60 tests
python3 -m pytest tests/ -q          # Quiet mode
python3 -m pytest tests/test_config.py -v  # Specific file
python3 -m pytest tests/ -k "test_status"  # Match pattern
```

**Manual testing:**
```bash
# Test help
./docklite my-command --help

# Test execution  
./docklite my-command

# Test with Docker group
sg docker -c "./docklite my-command"

# Test error handling
./docklite my-command --invalid-option
```

**Test Coverage:** 60 tests covering config, utils, commands

## Documentation

When adding scripts, update:
- [scripts/README.md](mdc:scripts/README.md) - Full docs
- [SCRIPTS.md](mdc:SCRIPTS.md) - Quick reference
- [scripts/docklite.sh](mdc:scripts/docklite.sh) - Help message
- [scripts/completion/docklite-completion.bash](mdc:scripts/completion/docklite-completion.bash) - Completion

## Examples (Python CLI)

**✅ Good command structure:**
```python
# scripts/cli/commands/maintenance.py
import typer
from pathlib import Path
from ..config import PROJECT_ROOT, BACKUPS_DIR, get_access_url
from ..utils.console import log_info, log_success, log_step, print_banner
from ..utils.docker import docker_compose_cmd
from ..utils.validation import check_docker

@app.command()
def backup(
    output: Path = typer.Option(None, "--output", "-o", help="Output directory")
):
    """Backup database and configuration."""
    print_banner("DockLite Backup")
    
    backup_dir = output or BACKUPS_DIR
    backup_dir.mkdir(parents=True, exist_ok=True)
    
    log_step("Creating backup...")
    # ... backup logic with Rich progress bar
    log_success("Backup complete!")
    log_info(f"File: [cyan]{backup_path}[/cyan]")
```

**❌ Bad - don't do this:**
```python
# No type hints
# Hardcoded paths
# Using print() instead of Rich

def backup(output):  # No type hints!
    print("Starting backup")  # Should use log_step!
    
    backup_dir = "/home/pavel/docklite/backups"  # Hardcoded! Use BACKUPS_DIR
    
    # Should use docker_compose_cmd from utils
    subprocess.run(["docker-compose", "exec", "backend", ...])
    
    print("Done")  # Should use log_success!
```

## Common Patterns (Python)

### With Docker Commands
```python
from cli.utils.docker import docker_compose_cmd
from cli.config import PROJECT_ROOT

# Execute docker-compose (handles sg docker automatically)
docker_compose_cmd("up", "-d", cwd=PROJECT_ROOT)
docker_compose_cmd("logs", "-f", "backend", cwd=PROJECT_ROOT)
```

### With User Confirmation
```python
from cli.utils.console import log_warning, log_info, log_step, confirm

log_warning("This will delete data!")
if not confirm("Continue?"):
    log_info("Cancelled")
    raise typer.Abort()

log_step("Deleting...")
# Do dangerous operation
```

### With File Backup
```python
from cli.utils.system import backup_file
from pathlib import Path

backup = backup_file(Path("/path/to/file.txt"))
# Creates: /path/to/file.txt.backup.20250129_123456
```

### With Error Handling
```python
from cli.utils.console import log_step, log_success, log_error

log_step("Running operation...")
try:
    # Some operation
    docker_compose_cmd("up", "-d", cwd=PROJECT_ROOT, check=True)
    log_success("Operation succeeded")
except Exception as e:
    log_error(f"Operation failed: {e}")
    raise typer.Exit(1)
```

### With Backend Helper (Database)
```python
# For database operations, create helper in backend/app/cli_helpers/

# scripts/cli/commands/maintenance.py
result = docker_compose_cmd(
    "exec", "-T", "backend",
    "python", "-m", "app.cli_helpers.my_helper", "command", "arg",
    cwd=PROJECT_ROOT,
    capture_output=True
)

output = result.stdout.strip()
# Parse and format with Rich
```

## Backend Helper Pattern

```python
# backend/app/cli_helpers/my_helper.py
import asyncio
import sys
import logging

# CRITICAL: Disable SQL logging
logging.getLogger('sqlalchemy.engine').setLevel(logging.WARNING)

# CRITICAL: Import all models to avoid circular imports
from app.core.database import AsyncSessionLocal
from app.models import user, project  # All models!
from app.models.user import User

async def my_operation():
    async with AsyncSessionLocal() as session:
        result = await session.execute(select(User))
        # Process...
        print("output_line")  # CLI parses this

if __name__ == "__main__":
    command = sys.argv[1] if len(sys.argv) > 1 else "default"
    asyncio.run(my_operation())
```
